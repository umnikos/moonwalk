include turtle.mw

" TODO: an actual system for overwriting methods please " del
: move dup moving success? not { dup detect { dup dig move } { dup attacking move } ifelse } { del } ifelse ;
: place dup placing success? not { dup detect { dup dig place } { dup attacking place } ifelse } { del } ifelse ;

:: sucking retry
	turtle.suck()
;;
:: sucking_down retry
	turtle.suckDown()
;;
:: negate_direction pure
	local dir = pop()
	if dir == "right" then
		push("left")
	elseif dir == "left" then
		push("right")
	else
		error("INVALID DIRECTION TO NEGATE")
	end
;;
:: mine_layer_update_counters_and_recurse pure
	local dir = pop()
	local x = pop()
	local y = pop()
	push(y-1)
	push(x)
	push(dir)
	unget_word("mine_layer_with_dir")
;;
:: reach pure
	local x = pop()
	local y = pop()
	local z = pop()
	push(z)
	push(y)
	push(x)
	push(z)
;;

: dump_inv # 1 select u place # 2 { dup select u drop # 1 add } # 14 times del # 1 select u dig ;
: maintain_inv # 15 select item_count # 0 = not { dump_inv } if # 1 select ;

: take_out # 1 select f dig sucking f move maintain_inv ;
: mine_row { take_out } swap # 1 sub times ;
: perform_turn dup turn take_out dup turn ;
: mine_layer_with_dir reach { over mine_row perform_turn negate_direction } swap # 1 sub times over mine_row ;

: mine_volume r swap { d dig sucking_down d move mine_layer_with_dir r turn r turn } swap times ;

crash

:: as_number pure
	push(deserialize(pop()))
;;
" Enter x dimension (towards the right): " print
read_line as_number
" Enter z dimension (towards the front): " print
read_line as_number
" Enter y dimension (downwards): " print
read_line as_number
mine_volume dump_inv
